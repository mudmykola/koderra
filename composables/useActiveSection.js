import {ref, onMounted, onBeforeUnmount, nextTick, watch} from 'vue'import {useRoute} from 'vue-router'export const useActiveSection = (ids = []) => {    const activeSection = ref('home')    const route = useRoute()    let observer = null    let retryTimeout = null    const updateHomeFallback = () => {        if (window.scrollY < 100) {            activeSection.value = 'home'        }    }    const callback = entries => {        const visibleSections = entries.filter(entry => entry.isIntersecting)        if (visibleSections.length > 0) {            activeSection.value = visibleSections[0].target.id        }    }    const setupObserver = async (retry = 0) => {        if (!('IntersectionObserver' in window)) return        if (observer) observer.disconnect()        await nextTick()        await nextTick()        observer = new IntersectionObserver(callback, {            root: null,            threshold: 0.3,            rootMargin: '0px 0px -20% 0px'        })        let foundCount = 0        ids.forEach(id => {            const el = document.getElementById(id)            console.log('id:', id, 'found:', !!el)            if (el) {                observer.observe(el)                foundCount++            }        })        if (foundCount < ids.length && retry < 10) {            setTimeout(() => setupObserver(retry + 1), 300)        }    }    onMounted(async () => {        await setupObserver()        window.addEventListener('scroll', updateHomeFallback)    })    watch(() => route.fullPath, async () => {        await setupObserver()    })    onBeforeUnmount(() => {        if (observer) observer.disconnect()        if (retryTimeout) clearTimeout(retryTimeout)        window.removeEventListener('scroll', updateHomeFallback)    })    return {activeSection}}